#include <stdio.h>
#include <time.h>
int main()
{
	srand(time(NULL));
	const int length = 20;
	/* Об'явлення основного масиву з довжиною length  */
	int massiv[length];
	/* Показчик на масив massiv */
	int* numToMassiv;
	numToMassiv = massiv;
	/* Заповнення псевдовипадковими числами масиву massiv */
	for (int i = 0; i < length; i++) {
		/* Пріоритетність спочатку у ВКАЗІВЦІ потім вираз після "=" ,потім аж інкремент для того,щоб записати 
		наступну цифру у масив */
		*numToMassiv++ = rand() % 10 + 1;
		/* Для зручності - виведення сгенерованих чисел */
		printf("%d ", massiv[i]);
	}
	printf("%s \n", "<-- Numbers\n");
	/*  Об'явлення результуючого масиву та його розміру size */
	int result[length];
	int size = 0;
	/* Вказівка р на індекс 0 масиву
	Тобто отримано у данному випадку нульовий індекс massiv */
	int* p = &massiv[0];
	for (int i = 0; i < length; i++) {
		/* Вказівка на поточне число використовуючи вказівку р */
		int* current = p + 1;
		/* Змінна для підрахунку кількості повторення КОНКРЕТНОГО елементу */
		int counter = 1;

		/* Вкладений цикл у якому перевіряється на збіжність цифр кожна цифра,використовуються вказівка *р на massiv
		та *current вказівка на поточне число */
		for (int j = i + 1; j < length; j++) { /*   */
			/* Якщо є збіжність = інкремент лічильника counter */
			if (*p == *current) {
				counter++;
			}
			/* Інкремент вказівки для переходу до наступного числа */
			current++;
		}
		/* Виконується перевірка на кількість співпадаючих чисел, (якщо counter =  1,звісно що поточне число має кількість 1,
		тому для простоти відразу беремо від кількості однакових чисел,якщо їх 2,та більше,йдемо далі */
		if (counter > 1) {
			/* Змінна для допомоги визначити розмір */
			int found = 0;
			/* Цикл йде через 2,бо запис йде по 2 елементи */
			for (int k = 0; k < size; k += 2)
			{
				/* За сутністю,це невеличка поправка, для стабільної роботи,щоб не було переповнення стеку пам'яті 
				Якщо Індекс пустий ,присвоюємо фаунд 1, виходимо з циклу й починаємо перевіряти нове число */
				if (result[k] == *p) {
					found = 1;
					break;
				}
			}/* Якщо !фаунд ,тобто found = 0 , записуемо елементи  */
			if (!found) {
				result[size++] = *p;
				result[size++] = counter;
			}
		}
		/* Інкремент для вказівки,щоб пройти далі по масиву */
		p++;
	}

	/* Виведення результуючого массиву */
	for (int i = 0; i < size; i++) {
		printf("%d\n", result[i]);
	}
}
